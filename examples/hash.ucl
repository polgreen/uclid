module main
{
  function hash(d1 : integer, h1 : integer) : integer;

  axiom forall (d1 : integer, d2 : integer, h1 : integer, h2 : integer) 
    // pattern[hash(d1, h1) == hash(d2, h2)] ::
    :: (d1 == d2 && h1 == h2) <==> hash(d1, h1) == hash(d2, h2);

  var dcopy : [integer]integer;
  var data  : [integer]integer;
  var dhash : integer;

  procedure compute_hash(d : [integer]integer)
    returns (h : integer)
  {
    var h1, h2 : integer;
    h1 = hash(d[0], d[1]);
    h2 = hash(d[2], d[3]);
    h  = hash(h1, h2);
  }

  init {
    dcopy = data;
    call (dhash) = compute_hash(data);
    data[4] = dhash;
  }

  next {
    if (*) {
      var idx  : integer;
      var arr1 : [integer]integer;
      var arrh : integer;

      arr1 = data[idx -> data[idx] + 1];
      call (arrh) = compute_hash(arr1);
      data' = arr1[4 -> arrh];
    }
  }

  invariant eq_data :
    (data[4] == dhash) ==>
        (data[0] == dcopy[0] && data[1] == dcopy[1] &&
         data[2] == dcopy[2] && data[3] == dcopy[3]);



  control {
    print_module;
    v = unroll(5);
    check;
    print_results;
  }
}
