module queue
{
  type op_t = enum { push, pop, nop };
  type index_t = integer;
  type count_t = integer;
  type data_t = integer;
  type queue_t = [index_t]data_t;

  const SIZE : integer = 4;

  var contents      : queue_t;
  var head, tail    : index_t;
  var count         : count_t;
  var inited        : boolean;

  input op          : op_t;
  input data        : integer;

  output first      : data_t;
  output valid      : boolean;
  output full       : boolean;
  output empty      : boolean;

  define is_empty() : boolean = (count == 0);
  define itemIndex(i : index_t) : index_t =
    if ((i + head) >= SIZE)
        then (i + head) - SIZE
        else (i + head);
  define in_queue(v : integer) : boolean =
    (exists (i : index_t) :: 
        (i >= 0 && i < count) && contents[itemIndex(i)] == v);

  init {
    head   = 0;
    tail   = 0;
    count  = 0;
    valid  = false;
    full   = false;
    empty  = true;
    inited = false;
  }

  procedure pushQ()
    returns (
        contentsP : queue_t,
        tailP : index_t,
        countP : integer)

    requires !full;
    requires (tail >= 0 && tail < SIZE);
    ensures (contentsP == contents[tail -> data]);
    ensures (tailP == if (tail == SIZE-1) then 0 else (tail + 1));
    ensures (countP == count + 1);
  {
    contentsP = contents[tail -> data];
    tailP = tail + 1;
    if (tailP >= SIZE) { tailP = 0; }
    countP = count + 1;
  }

  procedure popQ()
    returns (
        headP : integer,
        countP : integer)

    requires !empty;
    requires (head >= 0 && head < SIZE);
    ensures (headP == if (head == SIZE-1) then 0 else (head + 1));
    ensures (countP == count - 1);
  {
    headP = head + 1;
    if (headP >= SIZE) { headP = 0; }
    countP = count - 1;
  }

  procedure searchQ(v : data_t)
    returns (found : boolean)
    requires (count >= 0 && count <= SIZE);
    ensures (in_queue(v) <==> found);
  {
    var i : integer;

    i = 0;
    found = false;
    while (i < count)
      invariant (i >= 0 && i <= count); // This could be a target for SyGuS??
      invariant (exists (j : integer) :: j >= 0 && j < i && contents[itemIndex(j)] == v) <==> found;
    {
      if (contents[itemIndex(i)] == v) {
        found = true;
      }
      i = i + 1;
    }
  }

  next {
    inited' = true;
    first'  = contents[head];
    full'   = (count' == SIZE);
    empty'  = (count' == 0);

    case
      (op == push && !full) : {
        call (contents', tail', count') = pushQ();
      }
      (op == pop && !empty) : {
        if (!is_empty()) {
          call (head', count') = popQ();
        }
      }
    esac;
  }

  const pushed_data : data_t;

  // count is always between 0 and SIZE.
  invariant[LTL] count_valid:
    G(count >= 0 && count <= SIZE);

  invariant[LTL] queue_inserts :
    // if we push something
    G((inited && op == push && X(op != pop) &&
       data == pushed_data && !full)
    // it enters the queue
    ==> X(in_queue(pushed_data)));

  invariant[LTL] push_eventually_pops :
    // no NOPs
    G(op != nop)                ==>
    // no push when full
    G(op == push ==> !full)     ==>
    // no pop when empty
    G(op == pop  ==> !empty)    ==>
    // everything that is pushed will eventually be popped.
    G((inited && op == push && data == pushed_data) ==>
      F(op == pop && first == pushed_data));

  control {
    vQ      = bmc(5);
    vPush   = verify(pushQ);
    vPop    = verify(popQ);
    vSearch = verify(searchQ);
    check;
    print_results;
    vPush.print_cex(tail, tailP);
    vQ.print_cex(
        op, data, pushed_data,
        head, tail, first, count,
        contents[0], contents[1],
        contents[2], contents[3]);
  }
}
