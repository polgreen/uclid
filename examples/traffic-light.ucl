module traffic_light
{
  type light_t = enum { red, yellow, green };
  var step : integer;
  output light : light_t;

  const green_count = 1;
  const red_count   = 1;

  procedure next_light()
    modifies light;
    modifies step;
  {
    if (step == 0) {
      case
	    (light == green) : {
	      light = yellow;
	    }
	    (light == yellow) : {
	      light = red;
	      step  = red_count;
	    }
	    (light == red) : {
	      light = green;
	      step  = green_count;
	    }
	  esac
    } else {
      step = step - 1;
    }
  }

  next {
    call next_light();
  }
}

module main
{
  type light_t = traffic_light.light_t;

  var light1, light2 : light_t;

  instance light1_i : traffic_light(light : (light1));
  instance light2_i : traffic_light(light : (light2));

  init {
    assume (light1_i.light == red && light1_i.step == traffic_light.red_count);
    assume (light2_i.light == green && light2_i.step == traffic_light.green_count);
  }

  next {
    next (light1_i);
    next (light2_i);
  }

  property[LTL] atleast_one_red         : G(light1 == red || light2 == red);
  property[LTL] always_eventually_green : G(F(light1 == green)) && G(F(light2 == green));

  control {
    v = bmc(20);
    check;
    print_results;
  }
}
