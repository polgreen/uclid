// This module declares types that are used in the rest of the model.
module common {
  // addresses are uninterpreted types.
  type addr_t = bv8;
  type word_t = bv8;
  // memory
  type mem_t = [addr_t]word_t;
  // CPU operation.
  type op_t   = enum { op_mov, op_add, op_sub, op_load, op_store };
}

module cpu {
  // Import type aliases from common.
  type addr_t = common.addr_t;
  type mem_t  = common.mem_t;
  type word_t = common.word_t;
  type op_t   = common.op_t;
  
  // type of register file.
  type regindex_t; 
  type regs_t = [regindex_t]word_t;

  // imem is the program memory; an input to the module.
  input imem : mem_t;
  
  var dmem : mem_t;
  var regs : regs_t;
  var pc   : addr_t;

  // These are uninterpreted functions.
  function inst2op   (i : word_t) : op_t;
  function inst2reg0 (i : word_t) : regindex_t;
  function inst2reg1 (i : word_t) : regindex_t;
  function inst2imm  (i : word_t) : word_t;
  function inst2addr (i : word_t) : addr_t;

  var inst   : word_t;
  var result : word_t;

  procedure exec_inst(inst : word_t, pc : addr_t)
    returns (result : word_t, pc_next : addr_t)
    modifies regs;
  {
    var op     : op_t;
    var r0ind  : regindex_t;
    var r1ind  : regindex_t;
    var r0     : word_t;
    var r1     : word_t;

    // find operation
    op = inst2op(inst);
    // and operands
    r0ind = inst2reg0(inst);
    r1ind = inst2reg1(inst);
    r0 = regs[r0ind];
    r1 = regs[r1ind];
    // execute.
    case
      (op == op_mov)     : { result = inst2imm(inst); }
      (op == op_add)     : { result = r0 + r1; }
      (op == op_sub)     : { result = r0 - r1; }
      (op == op_load)    : { result = dmem[inst2addr(inst)]; }
      (op == op_store)   : { result = r0; }
    esac
    pc_next = pc + 1bv8;
    // store its result
    regs[r0ind] = result;
  }

  // Define initial state for the modules.
  init {
    assume (forall (r : regindex_t) :: regs[r] == 0bv8);
    assume (forall (a : addr_t) :: dmem[a] == 0bv8);
    pc = 0bv8;
    inst = 0bv8;
  }

  next {
    // get the next instruction.
    inst = imem[pc];
    // execute it
    call (result, pc) = exec_inst(inst, pc);
  }
}

module main {

  // Import types
  type addr_t     = common.addr_t;
  type mem_t      = common.mem_t;
  type word_t     = common.word_t;
  type op_t       = common.op_t;
  type regindex_t = cpu.regindex_t;
  
  // instruction memory is the same for both CPUs.
  var imem : mem_t;

  // Create two instances of the CPU module.
  instance cpu_i_1 : cpu(imem : (imem));
  instance cpu_i_2 : cpu(imem : (imem));

  init {
  }

  next {
    // Invoke CPU 1 and CPU 2.
    next (cpu_i_1);
    next (cpu_i_2);
  }
  
  // These are our properties.
  invariant eq_regs : (forall (ri : regindex_t) :: cpu_i_1->regs[ri] == cpu_i_2->regs[ri]);
  invariant eq_mem  : (forall (a : addr_t) :: cpu_i_1->dmem[a] == cpu_i_2->dmem[a]);
  invariant eq_pc   : (cpu_i_1->pc == cpu_i_2->pc);
  invariant eq_inst : (cpu_i_1->inst == cpu_i_2->inst);

  // Proof script.
  control {
    unroll(3);
    check;
    print_results;
  }
}
