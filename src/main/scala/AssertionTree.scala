/*
 * UCLID5 Verification and Synthesis Engine
 *
 * Copyright (c) 2017.
 * Sanjit A. Seshia, Rohit Sinha and Pramod Subramanyan.
 *
 * All Rights Reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 1. Redistributions of source code must retain the above copyright notice,
 *
 * this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 *
 * documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the copyright holder nor the names of its
 * contributors may be used to endorse or promote products derived from this
 * software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Author: Pramod Subramanyan

 * Class that manages proof obligations generated by UCLID5.
 *
 */

package uclid

import uclid.lang._

import scala.collection.mutable.ListBuffer

case class AssertInfo(
    name : String, label : String,
    frameTable : SymbolicSimulator.FrameTable,
    context : Scope,
    iter : Int,
    pathCond : smt.Expr,
    expr : smt.Expr,
    decorators : List[ExprDecorator],
    pos : ASTPosition) {
  override def toString = {
    label + " [Step #" + iter.toString + "] " + name + " @ " + pos.toString
  }
}

case class CheckResult(assert : AssertInfo, result : smt.SolverResult)

class AssertionTree {
  class TreeNode(p : Option[TreeNode], assumps : List[smt.Expr]) {
    var parent : Option[TreeNode] = p
    var children : ListBuffer[TreeNode] = ListBuffer.empty
    var assumptions: ListBuffer[smt.Expr] = assumps.to[ListBuffer]
    var assertions: ListBuffer[AssertInfo] = ListBuffer.empty
    var results : List[CheckResult] = List.empty

    // these two functions add assumptions.
    def +=(e : smt.Expr) { assumptions += e }
    // and these two add assertions
    def +=(assert: AssertInfo) { assertions += assert }
  }

  val root : TreeNode = new TreeNode(None, List.empty)
  val initialRoot : TreeNode = root
  var currentNode : TreeNode = root

  def addAssumption(assump: smt.Expr) {
    if (currentNode.assertions.size > 0) {
      val childNode = new TreeNode(Some(currentNode), List(assump))
      currentNode.children += childNode
      currentNode = childNode
    } else {
      currentNode += assump
    }
  }

  def addAssert(assert: AssertInfo) {
    currentNode += assert
  }

  def resetToInitial() {
    currentNode = initialRoot
  }

  def _verify(node : TreeNode, solver : smt.Context) : List[CheckResult] = {
    solver.push()
    node.assumptions.foreach(a => solver.assert(a))
    node.results = (node.assertions.map {
      e => {
        val pcExpr = e.pathCond
        val assertExpr = if (e.decorators.contains(CoverDecorator)) {
          e.expr
        } else {
          smt.OperatorApplication(smt.NegationOp, List(e.expr))
        }
        val checkExpr = if (pcExpr == smt.BooleanLit(true)) {
          assertExpr
        } else {
          smt.OperatorApplication(smt.ConjunctionOp, List(pcExpr, assertExpr))
        }
        solver.push()
        solver.assert(checkExpr)
        val sat = solver.check()
        val result = sat.result match {
          case Some(true)  => smt.SolverResult(Some(false), sat.model)
          case Some(false) => smt.SolverResult(Some(true), sat.model)
          case None        => smt.SolverResult(None, None)
        }
        solver.pop()
        CheckResult(e, result)
      }
    }).toList
    // now recurse into children
    val childResults = node.children.flatMap(c => _verify(c, solver))
    solver.pop()
    node.results ++ childResults
  }
  def verify(solver : smt.Context) : List[CheckResult] = _verify(root, solver)

  def _printSMT(node : TreeNode, parentAssumptions : List[smt.Expr], label : Option[Identifier], solver : smt.SolverInterface) : List[String] = {
    val allAssumptions = parentAssumptions ++ node.assumptions.toList
    val filteredAssertions = (label match {
      case None        => node.assertions
      case Some(label) =>
        node.assertions.filter{e => e.label == label.name}
    }).toList

    val theseSMTFormulas = filteredAssertions.map{
      a => {
        val name = label match {
          case None => "uclid: [%s]; step %d".format(a.pos.toString, a.iter)
          case Some(label) => "uclid(%s): [%s]; step %d".format(label, a.pos.toString, a.iter)
        }
        solver.toSMT2(smt.OperatorApplication(smt.ConjunctionOp, List(a.pathCond, a.expr)),
                      allAssumptions, name)
      }
    }
    val childResults = node.children.flatMap(c => _printSMT(c, allAssumptions, label, solver))
    theseSMTFormulas ++ childResults
  }
  def printSMT(label : Option[Identifier], solver : smt.SolverInterface) = _printSMT(root, List.empty, label, solver)
}
