module main {

  // U is the function V_f in the paper.
  define U(arr : [integer]boolean, n : integer) : boolean =
        (n >= 0) && (forall (i : integer) :: (i < 0 || i >= n) ==> !arr[i]);
  // V is the function V in the paper.
  define V(arr : [integer]boolean, n : integer) : boolean =
        (n >= 0) && (forall (i : integer) :: (i < 0 || i >= n) ==> !arr[i]) &&
                   (exists (i : integer) :: 0 <= i < n && arr[i]);
  // W is the function V_1 in the paper.
  define W(arr : [integer]boolean, n : integer) : boolean =
        (n >= 0) && (forall (i : integer) :: !arr[i]);
  define X(b : boolean) : boolean = true;

  proof {
    // The satisfying assignments to U are the disjoint union of the satisfying
    // assignments to V and W.
    assert disjoint: #[(arr: [integer]boolean) for (n : integer)] :: (U(arr, n)) ==
                     #[(arr: [integer]boolean) for (n : integer)] :: (V(arr, n)) +
                     #[(arr: [integer]boolean) for (n : integer)] :: (W(arr, n));
    // prove #arr: W(arr, n) == 1
    assert constEq:  (n >= 0) ==> #[(arr: [integer]boolean) for (n : integer)] :: (W(arr, n)) == 1;
    // prove #arr: U(arr, 1) == 1
    assert constEq:  (n == 0) ==> #[(arr: [integer]boolean) for (n : integer)] :: (U(arr, n)) == 1;
    // prove #i: X(b) == 2
    assert constEq:  #[(b : boolean) for (n : integer)] :: (X(b)) == 2;
    assert forall (n : integer) :: (#[(b : boolean) for (n : integer)] :: (X(b))) == 2;
    // prove the inductive step in the count. 
    // #arr. U(arr, n + 1) >= #arr. U(arr, n) * 2
    assert indLB: #[(arr: [integer]boolean) for (n : integer)] :: (U(arr, n+1)) >=
                  #[(arr: [integer]boolean) for (n : integer)] :: (U(arr, n))   *
                  #[(b : boolean) for (n : integer)] :: (X(b))
                  skolems (arr[n -> b]);
  }
}

