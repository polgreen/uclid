module common {
  // This module declares types that are used in the rest of the model.

  // Types can be bitvectors.
  type addr_t = bv8;
  type word_t = bv8;

  // Or enums.
  type op_t = enum { op_add, op_sub, op_load, op_store, op_syscall, op_sysret };
  type mode_t = enum { usr_mode, sup_mode };

  // Or SMT arrays.
  type mem_t = [addr_t]word_t;
}

module cpu {
  // Import type aliases from common.
  type addr_t = common :: addr_t;
  type mem_t = common :: mem_t;
  type word_t = common :: word_t;
  type op_t = common :: op_t;
  type mode_t = common :: mode_t;
  
  // Types can also be uninterpreted.
  type regindex_t; 
  // And we can use them in maps.
  type regs_t = [regindex_t]word_t;
  
  // These are the state variables of this module.
  var mem  : mem_t;
  var regs : regs_t;
  var pc   : addr_t;
  var mode : mode_t;

  // These are the constants in this module.
  const sup_range_lo : addr_t;
  const sup_range_hi : addr_t;
  
  // These are (uninterpreted) functions.
  function word2op     ( w : word_t )  : op_t;
  function word2reg0   ( w : word_t )  : regindex_t;
  function word2reg1   ( w : word_t )  : regindex_t;
  function word2nextPC ( w : word_t )  : addr_t;

  // More state variables ...
  var inst   : word_t;
  var op     : op_t;
  var r0ind  : regindex_t;
  var r1ind  : regindex_t;
  var r0     : word_t;
  var r1     : word_t;
  var result : word_t;

  // Define initial state for the modules.
  init {
      assume (forall (r : regindex_t) :: regs[r] == 0bv8);
      pc   := 0bv8;
      inst := 0bv8;
      mode := sup_mode;
  }

  // Define the "next" transitions.
  next {
      // get the next instruction.
      inst := mem[pc];
      // find its operation
      op := word2op(inst);
      // and its operands
      r0ind := word2reg0(inst);
      r1ind := word2reg1(inst);
      r0 := regs[r0ind];
      r1 := regs[r1ind];
      // default value of result!
      result := r0;
      // now execute

      // We have case statements!
      case
        (op == op_add)     : { result := r0 + r1; }
        (op == op_sub)     : { result := r0 - r1; }
        (op == op_load)    : { result := mem[r1]; }
        (op == op_store)   : { 
          // And if statements
          if (mode == sup_mode || r0 < sup_range_lo || r0 >= sup_range_hi) {
              mem[r0] := r1; 
          }
        }
        (op == op_syscall) : { mode := sup_mode; }
        (op == op_sysret)  : { mode := usr_mode; }
      esac
      regs[r0ind] := result;
      pc := pc + 1bv8;
  }
}
  
module main {
  // The is the "main" module: i.e. the module from which proof script commands are executed.

  // Import types
  type addr_t = common :: addr_t;
  type mem_t = common :: mem_t;
  type word_t = common :: word_t;
  type op_t = common :: op_t;
  type regindex_t = cpu :: regindex_t;
  
  // Create two instances of the CPU module.
  instance cpu_i_1 : cpu();
  instance cpu_i_2 : cpu();

  init {
    // Assume the two CPUs have the same initial state.
    assume (forall (a : addr_t) :: cpu_i_1->mem[a] == cpu_i_2->mem[a]);
    assume (cpu_i_1->sup_range_lo == cpu_i_2->sup_range_lo);
    assume (cpu_i_1->sup_range_hi == cpu_i_2->sup_range_hi);
  }

  next {
    // These call statements invoke the next state function of the two CPU module instances.
    call (cpu_i_1);
    call (cpu_i_2);
  }
  
  // These are our properties.
  property eq_regs : (forall (ri : regindex_t) :: cpu_i_1->regs[ri] == cpu_i_2->regs[ri]);
  property eq_mem  : (forall (a : addr_t) :: cpu_i_1->mem[a] == cpu_i_2->mem[a]);
  property eq_pc   : (cpu_i_1->pc == cpu_i_2->pc);
  property eq_inst : (cpu_i_1->inst == cpu_i_2->inst);

  // The control block defines the commands that will executed as part of the proof script.
  control {
    // initialize creates symbolic expressions for the init statements.
    initialize;
    // simulate(3) "unrolls" the module for 3 steps and creates symbolic
    // expressions for the assertions encountered during those three steps.
    simulate(3);
    // decide actually checks if these assertions hold.
    decide;
    // this prints out the results of the verification.
    print_results;

    // Some commands for debugging.
    // print_module;
    // print_cex (cpu_i_1->op, cpu_i_2->op, cpu_i_1->mem, cpu_i_2->mem);
    // print_cex (cpu_i_1->inst, cpu_i_2->inst, cpu_i_1->op, cpu_i_2->op, cpu_i_1->regs[0bv1], cpu_i_2->regs[0bv1], cpu_i_1->regs[1bv1], cpu_i_2->regs[1bv1]);
    // print_cex (cpu_i_1->inst, cpu_i_2->inst);
  }
}
