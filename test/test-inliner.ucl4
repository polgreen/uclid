module main {
  type bit_t = bv1;
  
  input x  : bit_t;
  input y  : bit_t;
  input z  : bit_t;

  output s0 : bit_t;
  output c0 : bit_t;
  output s1 : bit_t;
  output c1 : bit_t;
  
  procedure incr(w : int) returns (u: int) {
    u := w + 1;
  }
  
  procedure half_adder0(a : bit_t, b : bit_t) returns (s : bit_t, c_out : bit_t) {
    s := a ^ b;
    c_out := (a & b);
  }
  
  procedure half_adder1(a : bit_t, b : bit_t) returns (s : bit_t, c_out : bit_t) {
    var cnt : int;
    
  	if (a == 1bv1 && b == 0bv1) {
  	  s := 1bv1;
  	} else {
      if (a == 0bv1 && b == 1bv1) {
  	    s := 1bv1;
  	  } else {
  	    s := 0bv1;
  	  }
  	}
  	cnt := 0;
  	if ((a&b) == 1bv1) {
  	  cnt := cnt + 1;
  	}
  	
  	if (cnt == 1) {
  	  c_out := 1bv1;
  	} else {
  	  c_out := 0bv1;
  	}
  }
  
  procedure full_adder0(a : bit_t, b : bit_t, c_in : bit_t) returns (s : bit_t, c_out : bit_t) {
	s := a ^ b ^ c_in;
	c_out := (a & b) | (b & c_in) | (c_in & a);
  }
  
  procedure full_adder1(a : bit_t, b : bit_t, c_in : bit_t) returns (s : bit_t, c_out : bit_t) {
    var cnt : int;
	s := a ^ b ^ c_in;
	cnt := 0;
	
	if (a == 1bv1) {
	  call (cnt) := incr(cnt);
	}
	
	if (b == 1bv1) {
	  call (cnt) := incr(cnt);
	}
	
	if (c_in == 1bv1) {
	  call (cnt) := incr(cnt);
	}

	if (cnt >= 2) {
	  c_out := 1bv1;
	} else {
	  c_out := 0bv1;
	}
  }

  next {
  	call (s0, c0) := full_adder0(x, y, z);
  	call (s1, c1) := full_adder1(x, y, z);
  	
  	assert (s0 == s1);
  	assert (c0 == c1);
  }
  
  control {
  	initialize;
  	simulate (3);
  	decide;
  }
}  