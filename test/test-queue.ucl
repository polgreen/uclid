module common {
 type op_t = enum {push, pop, nop};

 const c0 : [integer]integer;
}


module queue
{
  type op_t = common :: op_t;

  var contents : [integer]integer;
  var head, tail: integer;

  output first: integer;

  input op : op_t;
  input data : integer;

  define is_empty() : boolean = (head == tail);
  define ptrs_valid() : boolean = (head <= tail);

  init {
    head = 0;
    tail = 0; 
    contents = common :: c0;
    first = contents[head];
  }

  next {
    first = contents[head];
    case
	(op == push) : {
	  contents[tail] = data;
      tail = tail+1;
    }
	(op == pop) : {
      if (!is_empty()) {
	    head = head+1;
      }
	}
	(op == nop) : { } /* no change */
    esac;
  }

  invariant head_le_tail: ptrs_valid(); 

  control {
    print_module;
    v = unroll(5);
    check;
    print_results;
    v->print_cex(op, head, tail);
  }
}

module main
{
  type op_t = common :: op_t;

  var op : op_t;
  var data : integer;

  var step : integer;
  
  instance queue_i : queue(op : (op), data : (data));

  init {
    op = nop;
    data = 0; 
    step = 0;
  }
  
  next {
    case
	(step == 0) || (step == 1) : { op = push; }
	(step == 2) || (step == 3) : { op = pop; }
	default : { op = nop; }
    esac
    step = step+1;
    data = data+1;
    next(queue_i);
  }
  
  control {
    unroll (5);
    check;
    print_results;
  }
}
