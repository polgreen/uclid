module common {
 type op_t = enum {push, pop, nop};

 const c0 : [int]int;
}


module queue
{
  type op_t = common :: op_t; /* do I need to do this, or can I just use common :: op_t instead? */

  var contents : [int]int;
  var head, tail: int;

  output first: int;

  input op : op_t;
  input data : int;

  // macrovar is_empty = (head == tail);
 
  init {
     head = 0;
     tail = 0;
     
     contents = common :: c0;
     first = contents[head];
  }

  next {
    first = contents[head];
    case
	(op == push) : { 
		contents[tail] = data;
		tail = tail+1;
                }
	(op == pop) : { 
                if (head < tail) {
		        head = head+1;
                }
		}
	(op == nop) : { } /* no change */
    esac;
  }

  invariant head_le_tail: head <= tail;

  control {
      v = unroll(2);
      check;
      print_results;
      v->print_cex(op, head, tail);
  }
}


module main
{
  type op_t = common :: op_t;

  var op : op_t;
  var data : int;

  var step : int;
  
  instance queue_i : queue(op : (op), data : (data));

  init {
    op = nop;
    data = 0; 
    step = 0;
  }
  
  next {
    case
	(step == 0) || (step == 1) : { op = push; }
	(step == 2) || (step == 3) : { op = pop; }
	default : { op = nop; }
    esac
    step = step+1;
    data = data+1;
    next(queue_i);
  }
  
  control {
    unroll (5);
    check;
    print_results;
  }
}
