module testModule {
  var y: bool;
  input mem_in : int -> int;
  type t1 = bool;
  type t2 = enum {red, green, blue};
  type t3 = record {a: int, b: int, c: bool};
  type t4 = record {a: int, b: int, c: record {d: bool, e: t1}};
  var z : t2;
  var a: [int] int;
  function f(i: int, b: bool) : record{a: int, b: int};

  procedure f(x: int, y_in: int) returns (z1:int) { 
    localvar x1: int;
    localvar y1: [int] int;
    localvar rec: record {f1: int, f2: record {a: int}};
    assume (x > 0); 
    assert (x < 1); 
    havoc y1; 
    x1,y1 := y1[0], y1; 
    rec.f1 := x;
    case 
        mem_in(x) > 0 : { x1 := (Lambda(b:bool). 2)(true); x1 := 2; }
        mem_in(x) < 0 : { x1 := (Lambda(i:int). i + 1)((Lambda(i:int). i)(2)); }
    esac 
  }

  output mem_out : [int] int;

  init {
    for i in range(0,1024) {
      a[i] := 1;
    }
    y := (Lambda(i:int,j:bool). true)(a[1],true);
  }
  next {
    for i in range(0,1024) {
      a[i] := ITE(i > 1000,1,2);
    }
    havoc y;
  }
}
