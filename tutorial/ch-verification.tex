\chapter{Verification Techniques}
\label{ch:verif}

In the examples covered thus far, we have only used \uclid{} for bounded model checking of invariants. 
\uclid{} can also be used to do unbounded inductive proofs and also provides support for debugging counterexamples. This chapter will describe these features of \uclid{}. Further features are being implemented and will be described in a future version of this document.

\section{Inductive Proofs} % change to \section when we have more sections!
Let us revisit the model from Example~\ref{ex:fib-model}. This is now shown again in Example~\ref{ex:fib-induction}, but with a different proof script. Instead of using the \codelike{unroll} command for bounded model checking, we are using the \codelike{induction} command to attempt an inductive proof.

\begin{uclidlisting}[htbp]
    \lstinputlisting[language=uclid,style=uclidstyle]{../examples/tutorial/ex3.1-fib-induction.ucl}
    \label{ex:fib-induction}
    \caption{\uclid{} Fibonacci model using induction in the proof script}
\end{uclidlisting}

\subsection{Debugging Counterexamples}

Let us try running \uclid{} on Example~\ref{ex:fib-induction} with the new proof script.
\begin{Verbatim}[frame=single, samepage=true]
$ uclid examples/tutorial/ex3.1-fib-induction.ucl 
1 assertions passed.
1 assertions failed.
0 assertions indeterminate.
  FAILED -> induction (step) [Step #1] property 
  a_le_b @ examples/tutorial/ex3-fib-induction.ucl, line 14
\end{Verbatim}

Uh oh, we seem to have a problem! \uclid{} is telling us that the inductive proof failed. We can try to examine why the proof failed by using the \codelike{print_cex} command to examine the counterexample to the proof.


\begin{uclidlisting}[htbp]
    \lstinputlisting[language=uclid,style=uclidstyle]{../examples/tutorial/ex3.2-fib-induction-cex.ucl}
    \caption{\uclid{} Fibonacci model with \codelike{induction} and \codelike{print_cex}}
    \label{ex:fib-induction-cex}
\end{uclidlisting}

The only changes between Example~\ref{ex:fib-induction} and Example~\ref{ex:fib-induction-cex} are on lines~18 and 21. \codelike{vobj} on line~18 is a reference to the verification conditions generated by the \codelike{induction} command. On line~21, we pass this reference to the \codelike{print_cex} command which prints out the values of \codelike{a} and \codelike{b} for the counterexample.

Running \uclid{} on Example~\ref{ex:fib-induction-cex} produces the following.

\begin{Verbatim}[frame=single, samepage=true]
1 assertions passed.
1 assertions failed.
0 assertions indeterminate.
  FAILED -> vobj [Step #1] property 
  a_le_b @ examples/tutorial/ex3.2-fib-induction-cex.ucl, 
  line 14
CEX for vobj [Step #1] property 
a_le_b @ examples/tutorial/ex3.2-fib-induction-cex.ucl, 
line 14
=================================
Step #0
  a : -1
  b : 0
=================================
=================================
Step #1
  a : 0
  b : -1
=================================
\end{Verbatim}

To understand the counterexample, it is helpful to review how the inductive proof engine works. When inductively proving the \keyword{invariant} \codelike{a_le_b}, \uclid{} considers some arbitrary state that satisfies this property, executes the \keyword{next} block, and checks whether \codelike{a_le_b} holds on the resultant state.

The counterexample shows us that we do start in a state where $\codelike{a} \le \codelike{b}$ with $\codelike{a}=-1$ and $\codelike{b}=0$. We execute the \keyword{next} block and now \codelike{a} gets the value of \codelike{b}, becoming 0 and \codelike{b} gets the value $\codelike{a} + \codelike{b}$, becoming -1. This new state does not satisfy the invariant!

What is the real problem here? Taking a closer look at Example~\ref{ex:fib-induction-cex}, we see that this specific counterexample can never occur in our model because \codelike{a} and \codelike{b} are always $\ge 0$. But \uclid{} does not know this when attempting the inductive proof. Therefore, we have to strengthen the inductive argument with this information in order to help \uclid{}'s proof.

\subsection{Inductive Proof for the Fibonacci Model}

Example~\ref{ex:fib-induction-proof} shows the same model as Example~\ref{ex:fib-induction-cex}, but with a stronger induction hypothesis. \uclid{}'s inductive engine will now start in an arbitrary state that assumes that both invariants \codelike{a_le_b} and \codelike{a_b_ge_0} hold and attempt to prove that both of these still hold after the \keyword{next} block is executed.

\begin{uclidlisting}[htbp]
    \lstinputlisting[language=uclid,style=uclidstyle]{../examples/tutorial/ex3.3-fib-induction-proof.ucl}
    \caption{Inductive proof for the Fibonacci model}
    \label{ex:fib-induction-proof}
\end{uclidlisting}

Let us now run \uclid{} on this new model.

\begin{Verbatim}[frame=single, samepage=true]
$ uclid examples/tutorial/ex3.3-fib-induction-proof.ucl 
4 assertions passed.
0 assertions failed.
0 assertions indeterminate.
\end{Verbatim}

Success! We have shown that our system model satisfies its specification.

\section{Bounded Model Checking}

\begin{uclidlisting}[htbp]
    \lstinputlisting[language=uclid,style=uclidstyle]{../examples/tutorial/ex3.4-fib-model-revisited.ucl}
    \caption{Revisiting the Fibonacci model from Example~\ref{ex:fib-model}.}
    \label{ex:fib-model-v2}
\end{uclidlisting}

Let us return to the model of Example~\ref{ex:fib-model} which is reproduced as Example~\ref{ex:fib-model-v2} with a few changes. We used the \codelike{unroll} command for verification. This command performs bounded model checking and takes a single argument -- the number of steps to unroll the model for. In Example~\ref{ex:fib-model-v2}, we are unrolling the model for 3 steps. 

\subsection{Embedded assume and assert statements}

A second difference with between Example~\ref{ex:fib-model} and Example~\ref{ex:fib-model-v2} is on lines 9,~10~and~15.

Instead of using a module-level assumption declarations as in Example~\ref{ex:fib-model}, we have two embedded assumptions in the \keywordbf{init} block on lines 9~and~10, and an embedded assertion in the \keywordbf{next} block on line 15. A module-level assumption is assumed to hold by the solver at every step of execution, while an embedded assumption is assumed ``instantaneously.'' In particular, the assumptions on lines~9--10 tells the solver to assume that $\codelike{a} \leq \codelike{b}$ at the end of the \keywordbf{init} block. Notice that we are not assigning specific values to \codelike{a} and \codelike{b}, instead we are asking \uclid{} to consider all values of \codelike{a} and \codelike{b} where $\codelike{a} \leq \codelike{b}$, $\codelike{a} \geq 0$ and $\codelike{b} \geq 0$.

Similarly the assertion on line~15 is evaluated at that specific location in the code (the end of the \keywordbf{next} block), whereas a module-level assertion would be evaluated after the \keywordbf{init} block and after the \keywordbf{next} block is evaluated at each step.

\subsection{Running \uclid{}}

Running \uclid{} on Example~\ref{ex:fib-model-v2} shows that the embedded assertion does indeed hold for all states reachable within 3 steps of the initial state.

\begin{Verbatim}[frame=single, samepage=true]
$ uclid examples/tutorial/ex3.4-fib-model-revisted.ucl 
3 assertions passed.
0 assertions failed.
0 assertions indeterminate.
\end{Verbatim}

\section{Future Directions}

Future versions of \uclid{} will have support for the verification of properties specified in linear temporal logic (LTL), as well as support for synthesizing invariants using Syntax-Guided Synthesis (SyGuS).
