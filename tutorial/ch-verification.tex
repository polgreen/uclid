\chapter{Verification Techniques}

Thus far, we have only used \uclid{} for bounded model checking. \uclid{} can also be used to do unbounded inductive proofs and also provides support for debugging counterexamples. This chapter will describe these features of \uclid{}.

\section{Inductive Proofs}
Let us revisit the model from Example~\ref{ex:fib-model}. This is now shown again in Example~\ref{ex:fib-induction}, but with a different proof script. Instead of using the \codelike{unroll} command for bounded model checking, we are using the \codelike{induction} command to attempt an inductive proof.

\begin{uclidlisting}[htbp]
\begin{lstlisting}[language=uclid,style=uclidstyle]
module main {
  // Part 1: System description.
  var a, b : int;

  init {
    a = 0;
    b = 1;
  }
  next {
    a, b = b, a + b;
  }

  // Part 2: System specification.
  invariant a_le_b: a <= b;

  // Part 3: Proof script.
  control {
    induction;
    check;
    print_results;
  }
}
\end{lstlisting}
\label{ex:fib-induction}
\caption{\uclid{} Fibonacci model using induction in the proof script}
\end{uclidlisting}

\subsection{Debugging Counterexamples}

Let us try running \uclid{} on Example~\ref{ex:fib-induction} with the new proof script.
\begin{Verbatim}[frame=single, samepage=true]
$ uclid examples/tutorial/ex3.1-fib-induction.ucl 
2 assertions passed.
1 assertions failed.
0 assertions indeterminate.
  FAILED -> induction (step) [Step #1] property 
  a_le_b @ examples/tutorial/ex3-fib-induction.ucl, line 14
\end{Verbatim}

Uh oh, we seem to have a problem! \uclid{} is telling us that the inductive proof failed. We can try to examine why the proof failed by using the \codelike{print_cex} command to examine the counterexample to the proof.


\begin{uclidlisting}[htbp]
\begin{lstlisting}[language=uclid,style=uclidstyle]
module main {
  // Part 1: System description.
  var a, b : int;

  init {
    a = 0;
    b = 1;
  }
  next {
    a, b = b, a + b;
  }

  // Part 2: System specification.
  invariant a_le_b: a <= b;

  // Part 3: Proof script.
  control {
    vobj = induction;
    check;
    print_results;
    vobj->print_cex(a, b);
  }
}
\end{lstlisting}
\caption{\uclid{} Fibonacci model with \codelike{induction} and \codelike{print_cex}}
\label{ex:fib-induction-cex}
\end{uclidlisting}

The only changes between Example~\ref{ex:fib-induction} and Example~\ref{ex:fib-induction-cex} are on lines~18 and 21. \codelike{vobj} on line~18 is a reference to the verification conditions generated by the \codelike{induction} command. On line~21, we pass this reference to the \codelike{print_cex} command which prints out the values of \codelike{a} and \codelike{b} for the counterexample.

Running \uclid{} on Example~\ref{ex:fib-induction-cex} produces the following.

\begin{Verbatim}[frame=single, samepage=true]
2 assertions passed.
1 assertions failed.
0 assertions indeterminate.
  FAILED -> vobj [Step #1] property 
  a_le_b @ examples/tutorial/ex3.2-fib-induction-cex.ucl, 
  line 14
CEX for vobj [Step #1] property 
a_le_b @ examples/tutorial/ex3.2-fib-induction-cex.ucl, 
line 14
=================================
Step #0
  a : -1
  b : 0
=================================
=================================
Step #1
  a : 0
  b : -1
=================================
\end{Verbatim}

To understand the counterexample, it is helpful to review how the inductive proof engine works. When inductively proving the \keyword{invariant} \codelike{a_le_b}, \uclid{} considers some arbitrary state that satisfies this property, executes the \keyword{next} block, and checks whether \codelike{a_le_b} holds on the resultant state.

The counterexample shows us that we do start in a state where $\codelike{a} \le \codelike{b}$ with $\codelike{a}=-1$ and $\codelike{b}=0$. We execute the \keyword{next} block and now \codelike{a} gets the value of \codelike{b}, becoming 0 and \codelike{b} gets the value $\codelike{a} + \codelike{b}$, becoming -1. This new state does not satisfy the invariant!

What is the real problem here? Taking a closer look at Example~\ref{ex:fib-induction-cex}, we see that this specific counterexample can never occur in our model because \codelike{a} and \codelike{b} are always $\ge 0$. But \uclid{} does not know this when attempting the inductive proof. Therefore, we have to strengthen the inductive argument with this information in order to help \uclid{}'s proof.

\subsection{Inductive Proof for the Fibonacci Model}

Example~\ref{ex:fib-induction-proof} shows the same model as Example~\ref{ex:fib-induction-cex}, but with a stronger induction hypothesis. \uclid{}'s inductive engine will now start in an arbitrary state that assumes that both invariants \codelike{a_le_b} and \codelike{a_b_ge_0} hold and attempt to prove that both of these still hold after the \keyword{next} block is executed.

\begin{uclidlisting}[htbp]
\begin{lstlisting}[language=uclid,style=uclidstyle]
module main {
  // Part 1: System description.
  var a, b : int;

  init {
    a = 0;
    b = 1;
  }
  next {
    a, b = b, a + b;
  }

  // Part 2: System specification.
  invariant a_le_b: a <= b;
  invariant a_b_ge_0: (a >= 0 && b >= 0);

  // Part 3: Proof script.
  control {
    vobj = induction;
    check;
    print_results;
    vobj->print_cex(a, b);
  }
}
\end{lstlisting}
\caption{Inductive proof for the Fibonacci model}
\label{ex:fib-induction-proof}
\end{uclidlisting}

Let us now run \uclid{} on this new model.

\begin{Verbatim}[frame=single, samepage=true]
$ uclid examples/tutorial/ex3.3-fib-induction-proof.ucl 
6 assertions passed.
0 assertions failed.
0 assertions indeterminate.
\end{Verbatim}

Success! We have shown that our system model satisfies its specification.

